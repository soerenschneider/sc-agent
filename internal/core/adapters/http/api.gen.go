//go:build go1.22

// Package http_server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package http_server

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for ReplicationHttpItemStatus.
const (
	ReplicationHttpItemStatusFailed          ReplicationHttpItemStatus = "failed"
	ReplicationHttpItemStatusInvalidChecksum ReplicationHttpItemStatus = "invalid_checksum"
	ReplicationHttpItemStatusSynced          ReplicationHttpItemStatus = "synced"
	ReplicationHttpItemStatusUnknown         ReplicationHttpItemStatus = "unknown"
)

// Defines values for ReplicationSecretsItemStatus.
const (
	ReplicationSecretsItemStatusFailed  ReplicationSecretsItemStatus = "failed"
	ReplicationSecretsItemStatusSynced  ReplicationSecretsItemStatus = "synced"
	ReplicationSecretsItemStatusUnknown ReplicationSecretsItemStatus = "unknown"
)

// Defines values for CertsSshGetCertificatesParamsType.
const (
	Host CertsSshGetCertificatesParamsType = "host"
	User CertsSshGetCertificatesParamsType = "user"
)

// Defines values for K0sPostActionParamsAction.
const (
	K0sPostActionParamsActionStart K0sPostActionParamsAction = "start"
	K0sPostActionParamsActionStop  K0sPostActionParamsAction = "stop"
)

// Defines values for LibvirtPostDomainActionParamsAction.
const (
	LibvirtPostDomainActionParamsActionReboot   LibvirtPostDomainActionParamsAction = "reboot"
	LibvirtPostDomainActionParamsActionShutdown LibvirtPostDomainActionParamsAction = "shutdown"
	LibvirtPostDomainActionParamsActionStart    LibvirtPostDomainActionParamsAction = "start"
)

// Defines values for PowerPostActionParamsAction.
const (
	Reboot   PowerPostActionParamsAction = "reboot"
	Shutdown PowerPostActionParamsAction = "shutdown"
)

// Defines values for PowerRebootManagerPostStatusParamsAction.
const (
	Pause   PowerRebootManagerPostStatusParamsAction = "pause"
	Unpause PowerRebootManagerPostStatusParamsAction = "unpause"
)

// Defines values for ServicesUnitStatusPutParamsAction.
const (
	Restart ServicesUnitStatusPutParamsAction = "restart"
	Start   ServicesUnitStatusPutParamsAction = "start"
	Stop    ServicesUnitStatusPutParamsAction = "stop"
)

// AcmeManagedCertificate The configuration of the managed ACME certificate
type AcmeManagedCertificate struct {
	// Certificate Returns the x509 certificate data
	Certificate *X509CertificateData `json:"certificate,omitempty"`

	// CertificateConfig Returns the configuration of a managed x509 certificate
	CertificateConfig *X509CertificateConfig   `json:"certificate_config,omitempty"`
	PostHooks         []PostHooks              `json:"post_hooks,omitempty"`
	StorageConfig     []X509CertificateStorage `json:"storage_config,omitempty"`
}

// AcmeManagedCertificateList The configuration of all configured managed ACME certificates
type AcmeManagedCertificateList struct {
	// Data The sync items
	Data []AcmeManagedCertificate `json:"data,omitempty"`
}

// InfoComponents Describes which components are enabled on the server
type InfoComponents struct {
	EnabledComponents []string `json:"enabled_components,omitempty"`
}

// PackageInfo Info about a single package
type PackageInfo struct {
	// Name Name of the package
	Name string `json:"name,omitempty"`

	// Repo Repository from which the package was installed
	Repo string `json:"repo,omitempty"`

	// Version Version of the package
	Version string `json:"version,omitempty"`
}

// PackageUpdates Returns whether system updates are available and which packages can be updated
type PackageUpdates struct {
	// UpdatablePackages List of packages that can be updated
	UpdatablePackages []PackageInfo `json:"updatable_packages,omitempty"`

	// UpdatesAvailable Indicates if there are updates available
	UpdatesAvailable bool `json:"updates_available,omitempty"`
}

// PackagesInstalled List of all the installed packages
type PackagesInstalled struct {
	// Packages List of installed packages
	Packages []PackageInfo `json:"packages,omitempty"`
}

// PkiIssuer Information about the certificate's issuer.
type PkiIssuer struct {
	// CommonName The common name of the issuer.
	CommonName string `json:"common_name"`

	// SerialNumber The serial number of the issuer.
	SerialNumber string `json:"serial_number"`
}

// PostHooks Hooks that are run after a cert has been issued
type PostHooks struct {
	// Cmd The command and its args that are run
	Cmd string `json:"cmd,omitempty"`

	// Name The name of the hook
	Name string `json:"name,omitempty"`
}

// Problem A generic HTTP problem
type Problem struct {
	// Detail A human-readable explanation specific to this occurrence of the problem
	Detail *string `json:"detail,omitempty"`

	// Instance A URI reference that identifies the specific occurrence of the problem
	Instance *string `json:"instance,omitempty"`

	// Status The HTTP status code
	Status *int `json:"status,omitempty"`

	// Title A short, human-readable summary of the problem type
	Title *string `json:"title,omitempty"`

	// Type A URI reference that identifies the problem type
	Type *string `json:"type,omitempty"`
}

// ReplicationHttpItem Configuration and status of a single HTTP replication item
type ReplicationHttpItem struct {
	// DestUris destination path where the read secret should be writen to
	DestUris []string `json:"dest_uris,omitempty"`

	// ExpectedChecksum only save the file if the checksum matches
	ExpectedChecksum *string `json:"expected_checksum,omitempty"`

	// Id id of the item
	Id        string      `json:"id,omitempty"`
	PostHooks []PostHooks `json:"post_hooks,omitempty"`

	// Source path of the secret to read and sync to the local filesystem
	Source string `json:"source,omitempty"`

	// Status the status of the synced secret
	Status ReplicationHttpItemStatus `json:"status,omitempty"`
}

// ReplicationHttpItemStatus the status of the synced secret
type ReplicationHttpItemStatus string

// ReplicationHttpItemsList All managed HTTP replication items
type ReplicationHttpItemsList struct {
	// Data The sync items
	Data []ReplicationHttpItem `json:"data,omitempty"`
}

// ReplicationSecretsItem Configuration and status of a single secret replication item
type ReplicationSecretsItem struct {
	// DestUri destination path where the read secret should be writen to
	DestUri string `json:"dest_uri,omitempty"`

	// Formatter name of the formatter
	Formatter string `json:"formatter,omitempty"`

	// Id id of the item
	Id string `json:"id,omitempty"`

	// SecretPath path of the secret to read and sync to the local filesystem
	SecretPath string `json:"secret_path,omitempty"`

	// Status the status of the synced secret
	Status *ReplicationSecretsItemStatus `json:"status,omitempty"`
}

// ReplicationSecretsItemStatus the status of the synced secret
type ReplicationSecretsItemStatus string

// ReplicationSecretsItemsList The configuration of all configured managed secrets replication items
type ReplicationSecretsItemsList struct {
	// Data The sync items
	Data []ReplicationSecretsItem `json:"data,omitempty"`
}

// ServiceLogs Represents log data. Each entry in the array represents a single line of data.
type ServiceLogs struct {
	Logs []string `json:"logs,omitempty"`
}

// ServiceLogsData Logs data for a service
type ServiceLogsData struct {
	// Data Represents log data. Each entry in the array represents a single line of data.
	Data  *ServiceLogs `json:"data,omitempty"`
	Error *string      `json:"error"`
}

// SshCertificateConfig Represents the configuration of a managed SSH certificate
type SshCertificateConfig struct {
	CertType string `json:"cert_type,omitempty"`

	// CertificateFile The file to write the signed cert to
	CertificateFile string `json:"certificate_file,omitempty"`

	// Id The id of this managed certificate
	Id         string   `json:"id,omitempty"`
	Principals []string `json:"principals,omitempty"`

	// PublicKeyFile The file to read the SSH public key from
	PublicKeyFile string `json:"public_key_file,omitempty"`

	// Role Name of the vault role
	Role string `json:"role,omitempty"`

	// Ttl The desired TTL of the signature
	Ttl string `json:"ttl,omitempty"`
}

// SshCertificateData The actual data of a SSH certificate
type SshCertificateData struct {
	// CriticalOptions A map of critical options associated with the certificate.
	CriticalOptions map[string]string `json:"critical_options,omitempty"`

	// Extensions A map of extensions associated with the certificate.
	Extensions map[string]string `json:"extensions,omitempty"`

	// Percentage Percentage associated with the certificate.
	Percentage float32 `json:"percentage,omitempty"`

	// Principals List of principals associated with the certificate.
	Principals []string `json:"principals,omitempty"`

	// Serial The serial number of the SSH certificate.
	Serial int64 `json:"serial,omitempty"`

	// Type The type of the certificate.
	Type string `json:"type,omitempty"`

	// ValidAfter The time after which the certificate is valid.
	ValidAfter time.Time `json:"valid_after,omitempty"`

	// ValidBefore The time before which the certificate is valid.
	ValidBefore time.Time `json:"valid_before,omitempty"`
}

// SshCertificateStorage The storage configuration of a managed SSH certificate
type SshCertificateStorage struct {
	// CertificateFile The file that the certificate will be written to
	CertificateFile string `json:"certificate_file,omitempty"`

	// PublicKeyFile The file that contains the public key to be signed
	PublicKeyFile string `json:"public_key_file,omitempty"`
}

// SshManagedCertificate Represents the configuration and storage information of a managed SSH certificate
type SshManagedCertificate struct {
	// Certificate The actual data of a SSH certificate
	Certificate *SshCertificateData `json:"certificate,omitempty"`

	// CertificateConfig Represents the configuration of a managed SSH certificate
	CertificateConfig *SshCertificateConfig `json:"certificate_config,omitempty"`

	// StorageConfig The storage configuration of a managed SSH certificate
	StorageConfig *SshCertificateStorage `json:"storage_config,omitempty"`
}

// SshManagedCertificatesList Returns a list of all the configured managed SSH certificate
type SshManagedCertificatesList struct {
	Data []SshManagedCertificate `json:"data,omitempty"`
}

// X509CertificateConfig Returns the configuration of a managed x509 certificate
type X509CertificateConfig struct {
	// AltNames A list of alternative names (SANs) for the certificate
	AltNames []string `json:"alt_names,omitempty"`

	// CommonName The common name (CN) for the certificate
	CommonName string `json:"common_name,omitempty"`

	// Id Unique identifier for the certificate configuration
	Id string `json:"id,omitempty"`

	// IpSans A list of IP SANs for the certificate
	IpSans []string `json:"ip_sans,omitempty"`

	// Role The role associated with the certificate
	Role string `json:"role,omitempty"`

	// Ttl The time-to-live (TTL) duration for the certificate
	Ttl string `json:"ttl,omitempty"`
}

// X509CertificateData Returns the x509 certificate data
type X509CertificateData struct {
	// EmailAddresses A list of email addresses associated with the certificate.
	EmailAddresses []string `json:"email_addresses,omitempty"`

	// Issuer Information about the certificate's issuer.
	Issuer PkiIssuer `json:"issuer"`

	// NotAfter The end date of the certificate's validity period.
	NotAfter time.Time `json:"not_after"`

	// NotBefore The start date of the certificate's validity period.
	NotBefore time.Time `json:"not_before"`

	// Percentage Lifetime of the certificate.
	Percentage float32 `json:"percentage,omitempty"`

	// Serial The serial number of the x509 certificate.
	Serial string `json:"serial"`

	// Subject The subject of the certificate.
	Subject string `json:"subject"`
}

// X509CertificateStorage The storage configuration of a managed x509 certificate
type X509CertificateStorage struct {
	// CaFile The file that the ca will be written to
	CaFile string `json:"ca_file,omitempty"`

	// CertFile The file that the cert will be written to
	CertFile string `json:"cert_file,omitempty"`

	// KeyFile The file that the key will be written to
	KeyFile string `json:"key_file,omitempty"`
}

// X509ManagedCertificate Represents the configuration of a managed x509 certificate
type X509ManagedCertificate struct {
	// CertificateConfig Returns the configuration of a managed x509 certificate
	CertificateConfig *X509CertificateConfig `json:"certificate_config,omitempty"`

	// CertificateData Returns the x509 certificate data
	CertificateData *X509CertificateData     `json:"certificate_data,omitempty"`
	PostHooks       []PostHooks              `json:"post_hooks,omitempty"`
	StorageConfig   []X509CertificateStorage `json:"storage_config,omitempty"`
}

// X509ManagedCertificateList Returns a list of all the configured managed PKI certificate
type X509ManagedCertificateList struct {
	Data []X509ManagedCertificate `json:"data,omitempty"`
}

// BadRequest A generic HTTP problem
type BadRequest = Problem

// Forbidden A generic HTTP problem
type Forbidden = Problem

// InternalServerError A generic HTTP problem
type InternalServerError = Problem

// NotFound A generic HTTP problem
type NotFound = Problem

// NotImplemented A generic HTTP problem
type NotImplemented = Problem

// Unauthorized A generic HTTP problem
type Unauthorized = Problem

// CertsSshGetCertificatesParams defines parameters for CertsSshGetCertificates.
type CertsSshGetCertificatesParams struct {
	// Type Specifies whether to return cert of type user or host. See Vault documentation.
	Type *CertsSshGetCertificatesParamsType `form:"type,omitempty" json:"type,omitempty"`
}

// CertsSshGetCertificatesParamsType defines parameters for CertsSshGetCertificates.
type CertsSshGetCertificatesParamsType string

// CertsSshPostIssueRequestsParams defines parameters for CertsSshPostIssueRequests.
type CertsSshPostIssueRequestsParams struct {
	// Id The id of the SSH host certificate you want to sign
	Id string `form:"id" json:"id"`

	// ForceRenewal Do not check the lifetime of the existing certificate against the threshold and force a new signature of the host key
	ForceRenewal *bool `form:"force-renewal,omitempty" json:"force-renewal,omitempty"`
}

// CertsX509PostIssueRequestsParams defines parameters for CertsX509PostIssueRequests.
type CertsX509PostIssueRequestsParams struct {
	// Id The id of the SSH host certificate you want to sign
	Id string `form:"id" json:"id"`

	// ForceRenewal Do not check the lifetime of the existing certificate against the threshold and force a new signature of the host key
	ForceRenewal *bool `form:"force-renewal,omitempty" json:"force-renewal,omitempty"`
}

// K0sPostActionParams defines parameters for K0sPostAction.
type K0sPostActionParams struct {
	// Action Action to perform for the k0s service
	Action K0sPostActionParamsAction `form:"action" json:"action"`
}

// K0sPostActionParamsAction defines parameters for K0sPostAction.
type K0sPostActionParamsAction string

// LibvirtPostDomainActionParams defines parameters for LibvirtPostDomainAction.
type LibvirtPostDomainActionParams struct {
	// Action Action to perform for the libvirt domain
	Action LibvirtPostDomainActionParamsAction `form:"action" json:"action"`
}

// LibvirtPostDomainActionParamsAction defines parameters for LibvirtPostDomainAction.
type LibvirtPostDomainActionParamsAction string

// PowerPostActionParams defines parameters for PowerPostAction.
type PowerPostActionParams struct {
	// Action Action to perform for the machine
	Action PowerPostActionParamsAction `form:"action" json:"action"`
}

// PowerPostActionParamsAction defines parameters for PowerPostAction.
type PowerPostActionParamsAction string

// PowerRebootManagerPostStatusParams defines parameters for PowerRebootManagerPostStatus.
type PowerRebootManagerPostStatusParams struct {
	// Action Action to perform for the reboot-manager service
	Action PowerRebootManagerPostStatusParamsAction `form:"action" json:"action"`
}

// PowerRebootManagerPostStatusParamsAction defines parameters for PowerRebootManagerPostStatus.
type PowerRebootManagerPostStatusParamsAction string

// ReplicationPostSecretsRequestsParams defines parameters for ReplicationPostSecretsRequests.
type ReplicationPostSecretsRequestsParams struct {
	// SecretPath The KV2 path of the secret that you want to trigger the sync for
	SecretPath string `form:"secret-path" json:"secret-path"`
}

// ServicesUnitStatusPutParams defines parameters for ServicesUnitStatusPut.
type ServicesUnitStatusPutParams struct {
	// Action Action to perform for the system service unit
	Action ServicesUnitStatusPutParamsAction `form:"action" json:"action"`
}

// ServicesUnitStatusPutParamsAction defines parameters for ServicesUnitStatusPut.
type ServicesUnitStatusPutParamsAction string

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Returns current configuration
	// (GET /v1/certs/acme)
	CertsAcmeGetCertificates(w http.ResponseWriter, r *http.Request)
	// Returns the replication status of a single item
	// (GET /v1/certs/acme/{id})
	CertsAcmeGetCertificate(w http.ResponseWriter, r *http.Request, id string)
	// Get the configuration of all managed ssh certificates
	// (GET /v1/certs/ssh)
	CertsSshGetCertificates(w http.ResponseWriter, r *http.Request, params CertsSshGetCertificatesParams)
	// Sign a SSH public key
	// (POST /v1/certs/ssh/issue-requests)
	CertsSshPostIssueRequests(w http.ResponseWriter, r *http.Request, params CertsSshPostIssueRequestsParams)
	// Get the configuration of a single managed ssh certificate
	// (GET /v1/certs/ssh/{id})
	CertsSshGetCertificate(w http.ResponseWriter, r *http.Request, id string)
	// Return configuration of all managed x509 certificates
	// (GET /v1/certs/x509)
	CertsX509GetCertificatesList(w http.ResponseWriter, r *http.Request)
	// Issues a X509 certificate
	// (POST /v1/certs/x509/issue-requests)
	CertsX509PostIssueRequests(w http.ResponseWriter, r *http.Request, params CertsX509PostIssueRequestsParams)
	// Returns info of configured managed x509 certificate
	// (GET /v1/certs/x509/{id})
	CertsX509GetCertificate(w http.ResponseWriter, r *http.Request, id string)
	// Returns all enabled components
	// (GET /v1/info/components)
	InfoGetComponents(w http.ResponseWriter, r *http.Request)
	// Start k0s
	// (POST /v1/k0s/actions)
	K0sPostAction(w http.ResponseWriter, r *http.Request, params K0sPostActionParams)
	// Set status of libvirt domain
	// (POST /v1/libvirt/domains/{domain})
	LibvirtPostDomainAction(w http.ResponseWriter, r *http.Request, domain string, params LibvirtPostDomainActionParams)
	// Lists installed packages
	// (GET /v1/packages/installed)
	PackagesInstalledGet(w http.ResponseWriter, r *http.Request)
	// Checks for updates
	// (GET /v1/packages/updates)
	PackagesUpdatesGet(w http.ResponseWriter, r *http.Request)
	// Upgrades all packages
	// (POST /v1/packages/upgrade-requests)
	PackagesUpgradeRequestsPost(w http.ResponseWriter, r *http.Request)
	// Directly interact with the power status of the system
	// (POST /v1/power-state)
	PowerPostAction(w http.ResponseWriter, r *http.Request, params PowerPostActionParams)
	// Unpause reboot status
	// (PUT /v1/power-state/reboot-manager)
	PowerRebootManagerPostStatus(w http.ResponseWriter, r *http.Request, params PowerRebootManagerPostStatusParams)
	// Get reboot status
	// (GET /v1/power-state/reboot-manager/status)
	PowerRebootManagerGetStatus(w http.ResponseWriter, r *http.Request)
	// Returns current configuration
	// (GET /v1/replication/http/items)
	ReplicationGetHttpItemsList(w http.ResponseWriter, r *http.Request)
	// Returns the replication status of a single item
	// (GET /v1/replication/http/items/{id})
	ReplicationGetHttpItem(w http.ResponseWriter, r *http.Request, id string)
	// Returns current configuration
	// (GET /v1/replication/secrets/items)
	ReplicationGetSecretsItemsList(w http.ResponseWriter, r *http.Request)
	// Returns the replication status of a single item
	// (GET /v1/replication/secrets/items/{id})
	ReplicationGetSecretsItem(w http.ResponseWriter, r *http.Request, id string)
	// Replicate a secret from Vault
	// (POST /v1/replication/secrets/sync-requests)
	ReplicationPostSecretsRequests(w http.ResponseWriter, r *http.Request, params ReplicationPostSecretsRequestsParams)
	// Get logs of a system service unit
	// (GET /v1/services/{unit}/logs)
	ServicesUnitLogsGet(w http.ResponseWriter, r *http.Request, unit string)
	// Interact with a system service
	// (PUT /v1/services/{unit}/status)
	ServicesUnitStatusPut(w http.ResponseWriter, r *http.Request, unit string, params ServicesUnitStatusPutParams)
	// Send a WOL packet
	// (POST /v1/wol-message/{alias})
	WolPostMessage(w http.ResponseWriter, r *http.Request, alias string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// CertsAcmeGetCertificates operation middleware
func (siw *ServerInterfaceWrapper) CertsAcmeGetCertificates(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CertsAcmeGetCertificates(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CertsAcmeGetCertificate operation middleware
func (siw *ServerInterfaceWrapper) CertsAcmeGetCertificate(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CertsAcmeGetCertificate(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CertsSshGetCertificates operation middleware
func (siw *ServerInterfaceWrapper) CertsSshGetCertificates(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CertsSshGetCertificatesParams

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", r.URL.Query(), &params.Type)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "type", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CertsSshGetCertificates(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CertsSshPostIssueRequests operation middleware
func (siw *ServerInterfaceWrapper) CertsSshPostIssueRequests(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CertsSshPostIssueRequestsParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "force-renewal" -------------

	err = runtime.BindQueryParameter("form", true, false, "force-renewal", r.URL.Query(), &params.ForceRenewal)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "force-renewal", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CertsSshPostIssueRequests(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CertsSshGetCertificate operation middleware
func (siw *ServerInterfaceWrapper) CertsSshGetCertificate(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CertsSshGetCertificate(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CertsX509GetCertificatesList operation middleware
func (siw *ServerInterfaceWrapper) CertsX509GetCertificatesList(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CertsX509GetCertificatesList(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CertsX509PostIssueRequests operation middleware
func (siw *ServerInterfaceWrapper) CertsX509PostIssueRequests(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CertsX509PostIssueRequestsParams

	// ------------- Required query parameter "id" -------------

	if paramValue := r.URL.Query().Get("id"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "id"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "force-renewal" -------------

	err = runtime.BindQueryParameter("form", true, false, "force-renewal", r.URL.Query(), &params.ForceRenewal)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "force-renewal", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CertsX509PostIssueRequests(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CertsX509GetCertificate operation middleware
func (siw *ServerInterfaceWrapper) CertsX509GetCertificate(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CertsX509GetCertificate(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// InfoGetComponents operation middleware
func (siw *ServerInterfaceWrapper) InfoGetComponents(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InfoGetComponents(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// K0sPostAction operation middleware
func (siw *ServerInterfaceWrapper) K0sPostAction(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params K0sPostActionParams

	// ------------- Required query parameter "action" -------------

	if paramValue := r.URL.Query().Get("action"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "action"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "action", r.URL.Query(), &params.Action)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "action", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.K0sPostAction(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// LibvirtPostDomainAction operation middleware
func (siw *ServerInterfaceWrapper) LibvirtPostDomainAction(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "domain" -------------
	var domain string

	err = runtime.BindStyledParameterWithOptions("simple", "domain", r.PathValue("domain"), &domain, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "domain", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LibvirtPostDomainActionParams

	// ------------- Required query parameter "action" -------------

	if paramValue := r.URL.Query().Get("action"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "action"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "action", r.URL.Query(), &params.Action)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "action", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LibvirtPostDomainAction(w, r, domain, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PackagesInstalledGet operation middleware
func (siw *ServerInterfaceWrapper) PackagesInstalledGet(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PackagesInstalledGet(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PackagesUpdatesGet operation middleware
func (siw *ServerInterfaceWrapper) PackagesUpdatesGet(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PackagesUpdatesGet(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PackagesUpgradeRequestsPost operation middleware
func (siw *ServerInterfaceWrapper) PackagesUpgradeRequestsPost(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PackagesUpgradeRequestsPost(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PowerPostAction operation middleware
func (siw *ServerInterfaceWrapper) PowerPostAction(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PowerPostActionParams

	// ------------- Required query parameter "action" -------------

	if paramValue := r.URL.Query().Get("action"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "action"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "action", r.URL.Query(), &params.Action)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "action", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PowerPostAction(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PowerRebootManagerPostStatus operation middleware
func (siw *ServerInterfaceWrapper) PowerRebootManagerPostStatus(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PowerRebootManagerPostStatusParams

	// ------------- Required query parameter "action" -------------

	if paramValue := r.URL.Query().Get("action"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "action"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "action", r.URL.Query(), &params.Action)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "action", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PowerRebootManagerPostStatus(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PowerRebootManagerGetStatus operation middleware
func (siw *ServerInterfaceWrapper) PowerRebootManagerGetStatus(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PowerRebootManagerGetStatus(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ReplicationGetHttpItemsList operation middleware
func (siw *ServerInterfaceWrapper) ReplicationGetHttpItemsList(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReplicationGetHttpItemsList(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ReplicationGetHttpItem operation middleware
func (siw *ServerInterfaceWrapper) ReplicationGetHttpItem(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReplicationGetHttpItem(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ReplicationGetSecretsItemsList operation middleware
func (siw *ServerInterfaceWrapper) ReplicationGetSecretsItemsList(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReplicationGetSecretsItemsList(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ReplicationGetSecretsItem operation middleware
func (siw *ServerInterfaceWrapper) ReplicationGetSecretsItem(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReplicationGetSecretsItem(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ReplicationPostSecretsRequests operation middleware
func (siw *ServerInterfaceWrapper) ReplicationPostSecretsRequests(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ReplicationPostSecretsRequestsParams

	// ------------- Required query parameter "secret-path" -------------

	if paramValue := r.URL.Query().Get("secret-path"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "secret-path"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "secret-path", r.URL.Query(), &params.SecretPath)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "secret-path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReplicationPostSecretsRequests(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ServicesUnitLogsGet operation middleware
func (siw *ServerInterfaceWrapper) ServicesUnitLogsGet(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "unit" -------------
	var unit string

	err = runtime.BindStyledParameterWithOptions("simple", "unit", r.PathValue("unit"), &unit, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "unit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ServicesUnitLogsGet(w, r, unit)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ServicesUnitStatusPut operation middleware
func (siw *ServerInterfaceWrapper) ServicesUnitStatusPut(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "unit" -------------
	var unit string

	err = runtime.BindStyledParameterWithOptions("simple", "unit", r.PathValue("unit"), &unit, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "unit", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ServicesUnitStatusPutParams

	// ------------- Required query parameter "action" -------------

	if paramValue := r.URL.Query().Get("action"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "action"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "action", r.URL.Query(), &params.Action)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "action", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ServicesUnitStatusPut(w, r, unit, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// WolPostMessage operation middleware
func (siw *ServerInterfaceWrapper) WolPostMessage(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "alias" -------------
	var alias string

	err = runtime.BindStyledParameterWithOptions("simple", "alias", r.PathValue("alias"), &alias, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "alias", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.WolPostMessage(w, r, alias)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/v1/certs/acme", wrapper.CertsAcmeGetCertificates)
	m.HandleFunc("GET "+options.BaseURL+"/v1/certs/acme/{id}", wrapper.CertsAcmeGetCertificate)
	m.HandleFunc("GET "+options.BaseURL+"/v1/certs/ssh", wrapper.CertsSshGetCertificates)
	m.HandleFunc("POST "+options.BaseURL+"/v1/certs/ssh/issue-requests", wrapper.CertsSshPostIssueRequests)
	m.HandleFunc("GET "+options.BaseURL+"/v1/certs/ssh/{id}", wrapper.CertsSshGetCertificate)
	m.HandleFunc("GET "+options.BaseURL+"/v1/certs/x509", wrapper.CertsX509GetCertificatesList)
	m.HandleFunc("POST "+options.BaseURL+"/v1/certs/x509/issue-requests", wrapper.CertsX509PostIssueRequests)
	m.HandleFunc("GET "+options.BaseURL+"/v1/certs/x509/{id}", wrapper.CertsX509GetCertificate)
	m.HandleFunc("GET "+options.BaseURL+"/v1/info/components", wrapper.InfoGetComponents)
	m.HandleFunc("POST "+options.BaseURL+"/v1/k0s/actions", wrapper.K0sPostAction)
	m.HandleFunc("POST "+options.BaseURL+"/v1/libvirt/domains/{domain}", wrapper.LibvirtPostDomainAction)
	m.HandleFunc("GET "+options.BaseURL+"/v1/packages/installed", wrapper.PackagesInstalledGet)
	m.HandleFunc("GET "+options.BaseURL+"/v1/packages/updates", wrapper.PackagesUpdatesGet)
	m.HandleFunc("POST "+options.BaseURL+"/v1/packages/upgrade-requests", wrapper.PackagesUpgradeRequestsPost)
	m.HandleFunc("POST "+options.BaseURL+"/v1/power-state", wrapper.PowerPostAction)
	m.HandleFunc("PUT "+options.BaseURL+"/v1/power-state/reboot-manager", wrapper.PowerRebootManagerPostStatus)
	m.HandleFunc("GET "+options.BaseURL+"/v1/power-state/reboot-manager/status", wrapper.PowerRebootManagerGetStatus)
	m.HandleFunc("GET "+options.BaseURL+"/v1/replication/http/items", wrapper.ReplicationGetHttpItemsList)
	m.HandleFunc("GET "+options.BaseURL+"/v1/replication/http/items/{id}", wrapper.ReplicationGetHttpItem)
	m.HandleFunc("GET "+options.BaseURL+"/v1/replication/secrets/items", wrapper.ReplicationGetSecretsItemsList)
	m.HandleFunc("GET "+options.BaseURL+"/v1/replication/secrets/items/{id}", wrapper.ReplicationGetSecretsItem)
	m.HandleFunc("POST "+options.BaseURL+"/v1/replication/secrets/sync-requests", wrapper.ReplicationPostSecretsRequests)
	m.HandleFunc("GET "+options.BaseURL+"/v1/services/{unit}/logs", wrapper.ServicesUnitLogsGet)
	m.HandleFunc("PUT "+options.BaseURL+"/v1/services/{unit}/status", wrapper.ServicesUnitStatusPut)
	m.HandleFunc("POST "+options.BaseURL+"/v1/wol-message/{alias}", wrapper.WolPostMessage)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

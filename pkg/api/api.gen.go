// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for FileValidationTest.
const (
	EndsWith   FileValidationTest = "ends_with"
	Regex      FileValidationTest = "regex"
	Sha256     FileValidationTest = "sha256"
	StartsWith FileValidationTest = "starts_with"
)

// Defines values for ReplicationHttpItemStatus.
const (
	ReplicationHttpItemStatusFailed           ReplicationHttpItemStatus = "failed"
	ReplicationHttpItemStatusSynced           ReplicationHttpItemStatus = "synced"
	ReplicationHttpItemStatusUnknown          ReplicationHttpItemStatus = "unknown"
	ReplicationHttpItemStatusValidationFailed ReplicationHttpItemStatus = "validation_failed"
)

// Defines values for ReplicationSecretsItemFormatter.
const (
	Env      ReplicationSecretsItemFormatter = "env"
	Json     ReplicationSecretsItemFormatter = "json"
	Template ReplicationSecretsItemFormatter = "template"
	Yaml     ReplicationSecretsItemFormatter = "yaml"
)

// Defines values for ReplicationSecretsItemStatus.
const (
	ReplicationSecretsItemStatusFailed  ReplicationSecretsItemStatus = "failed"
	ReplicationSecretsItemStatusSynced  ReplicationSecretsItemStatus = "synced"
	ReplicationSecretsItemStatusUnknown ReplicationSecretsItemStatus = "unknown"
)

// Defines values for CertsSshGetCertificatesParamsType.
const (
	Host CertsSshGetCertificatesParamsType = "host"
	User CertsSshGetCertificatesParamsType = "user"
)

// Defines values for K0sPostActionParamsAction.
const (
	K0sPostActionParamsActionStart K0sPostActionParamsAction = "start"
	K0sPostActionParamsActionStop  K0sPostActionParamsAction = "stop"
)

// Defines values for LibvirtPostDomainActionParamsAction.
const (
	LibvirtPostDomainActionParamsActionReboot   LibvirtPostDomainActionParamsAction = "reboot"
	LibvirtPostDomainActionParamsActionShutdown LibvirtPostDomainActionParamsAction = "shutdown"
	LibvirtPostDomainActionParamsActionStart    LibvirtPostDomainActionParamsAction = "start"
)

// Defines values for PowerPostActionParamsAction.
const (
	Reboot   PowerPostActionParamsAction = "reboot"
	Shutdown PowerPostActionParamsAction = "shutdown"
)

// Defines values for PowerRebootManagerPostStatusParamsAction.
const (
	Pause   PowerRebootManagerPostStatusParamsAction = "pause"
	Unpause PowerRebootManagerPostStatusParamsAction = "unpause"
)

// Defines values for ServicesUnitStatusPutParamsAction.
const (
	Restart ServicesUnitStatusPutParamsAction = "restart"
	Start   ServicesUnitStatusPutParamsAction = "start"
	Stop    ServicesUnitStatusPutParamsAction = "stop"
)

// AcmeManagedCertificate The configuration of the managed ACME certificate
type AcmeManagedCertificate struct {
	// Certificate Returns the x509 certificate data
	Certificate *X509CertificateData `json:"certificate,omitempty"`

	// CertificateConfig Returns the configuration of a managed x509 certificate
	CertificateConfig *X509CertificateConfig   `json:"certificate_config,omitempty"`
	PostHooks         []PostHooks              `json:"post_hooks,omitempty"`
	StorageConfig     []X509CertificateStorage `json:"storage_config,omitempty"`
}

// AcmeManagedCertificateList The configuration of all configured managed ACME certificates
type AcmeManagedCertificateList struct {
	// Data The sync items
	Data []AcmeManagedCertificate `json:"data,omitempty"`
}

// FileValidation Validates a file's content
type FileValidation struct {
	// Arg the value to test against
	Arg string `json:"arg,omitempty"`

	// InvertResult invert the result of the check
	InvertResult bool `json:"invert_result,omitempty"`

	// Test The type of validation to perform.
	Test FileValidationTest `json:"test,omitempty"`
}

// FileValidationTest The type of validation to perform.
type FileValidationTest string

// InfoComponents Describes which components are enabled on the server
type InfoComponents struct {
	EnabledComponents []string `json:"enabled_components,omitempty"`
}

// PackageInfo Info about a single package
type PackageInfo struct {
	// Name Name of the package
	Name string `json:"name,omitempty"`

	// Repo Repository from which the package was installed
	Repo string `json:"repo,omitempty"`

	// Version Version of the package
	Version string `json:"version,omitempty"`
}

// PackageUpdates Returns whether system updates are available and which packages can be updated
type PackageUpdates struct {
	// UpdatablePackages List of packages that can be updated
	UpdatablePackages []PackageInfo `json:"updatable_packages,omitempty"`

	// UpdatesAvailable Indicates if there are updates available
	UpdatesAvailable bool `json:"updates_available,omitempty"`
}

// PackagesInstalled List of all the installed packages
type PackagesInstalled struct {
	// Packages List of installed packages
	Packages []PackageInfo `json:"packages,omitempty"`
}

// PkiIssuer Information about the certificate's issuer.
type PkiIssuer struct {
	// CommonName The common name of the issuer.
	CommonName string `json:"common_name"`

	// SerialNumber The serial number of the issuer.
	SerialNumber string `json:"serial_number"`
}

// PostHooks Hooks that are run after a cert has been issued
type PostHooks struct {
	// Cmd The command and its args that are run
	Cmd string `json:"cmd,omitempty"`

	// Name The name of the hook
	Name string `json:"name,omitempty"`
}

// Problem A generic HTTP problem
type Problem struct {
	// Detail A human-readable explanation specific to this occurrence of the problem
	Detail *string `json:"detail,omitempty"`

	// Instance A URI reference that identifies the specific occurrence of the problem
	Instance *string `json:"instance,omitempty"`

	// Status The HTTP status code
	Status *int `json:"status,omitempty"`

	// Title A short, human-readable summary of the problem type
	Title *string `json:"title,omitempty"`

	// Type A URI reference that identifies the problem type
	Type *string `json:"type,omitempty"`
}

// ReplicationHttpItem Configuration and status of a single HTTP replication item
type ReplicationHttpItem struct {
	// DestUris destination path where the read secret should be writen to
	DestUris []string `json:"dest_uris,omitempty"`

	// FileValidation Validates a file's content
	FileValidation *FileValidation `json:"file_validation,omitempty"`

	// Id id of the item
	Id        string      `json:"id,omitempty"`
	PostHooks []PostHooks `json:"post_hooks,omitempty"`

	// Source path of the secret to read and sync to the local filesystem
	Source string `json:"source,omitempty"`

	// Status the status of the synced secret
	Status ReplicationHttpItemStatus `json:"status,omitempty"`
}

// ReplicationHttpItemStatus the status of the synced secret
type ReplicationHttpItemStatus string

// ReplicationHttpItemsList All managed HTTP replication items
type ReplicationHttpItemsList struct {
	// Data The sync items
	Data []ReplicationHttpItem `json:"data,omitempty"`
}

// ReplicationSecretsItem Configuration and status of a single secret replication item
type ReplicationSecretsItem struct {
	// DestUri destination path where the read secret should be writen to
	DestUri string `json:"dest_uri,omitempty"`

	// Formatter name of the formatter
	Formatter ReplicationSecretsItemFormatter `json:"formatter,omitempty"`

	// Id id of the item
	Id string `json:"id,omitempty"`

	// SecretPath path of the secret to read and sync to the local filesystem
	SecretPath string `json:"secret_path,omitempty"`

	// Status the status of the synced secret
	Status *ReplicationSecretsItemStatus `json:"status,omitempty"`
}

// ReplicationSecretsItemFormatter name of the formatter
type ReplicationSecretsItemFormatter string

// ReplicationSecretsItemStatus the status of the synced secret
type ReplicationSecretsItemStatus string

// ReplicationSecretsItemsList The configuration of all configured managed secrets replication items
type ReplicationSecretsItemsList struct {
	// Data The sync items
	Data []ReplicationSecretsItem `json:"data,omitempty"`
}

// ServiceLogs Represents log data. Each entry in the array represents a single line of data.
type ServiceLogs struct {
	Logs []string `json:"logs,omitempty"`
}

// ServiceLogsData Logs data for a service
type ServiceLogsData struct {
	// Data Represents log data. Each entry in the array represents a single line of data.
	Data  *ServiceLogs `json:"data,omitempty"`
	Error *string      `json:"error"`
}

// SshCertificateConfig Represents the configuration of a managed SSH certificate
type SshCertificateConfig struct {
	CertType string `json:"cert_type,omitempty"`

	// CertificateFile The file to write the signed cert to
	CertificateFile string `json:"certificate_file,omitempty"`

	// Id The id of this managed certificate
	Id         string   `json:"id,omitempty"`
	Principals []string `json:"principals,omitempty"`

	// PublicKeyFile The file to read the SSH public key from
	PublicKeyFile string `json:"public_key_file,omitempty"`

	// Role Name of the vault role
	Role string `json:"role,omitempty"`

	// Ttl The desired TTL of the signature
	Ttl string `json:"ttl,omitempty"`
}

// SshCertificateData The actual data of a SSH certificate
type SshCertificateData struct {
	// CriticalOptions A map of critical options associated with the certificate.
	CriticalOptions map[string]string `json:"critical_options,omitempty"`

	// Extensions A map of extensions associated with the certificate.
	Extensions map[string]string `json:"extensions,omitempty"`

	// Percentage Percentage associated with the certificate.
	Percentage float32 `json:"percentage,omitempty"`

	// Principals List of principals associated with the certificate.
	Principals []string `json:"principals,omitempty"`

	// Serial The serial number of the SSH certificate.
	Serial int64 `json:"serial,omitempty"`

	// Type The type of the certificate.
	Type string `json:"type,omitempty"`

	// ValidAfter The time after which the certificate is valid.
	ValidAfter time.Time `json:"valid_after,omitempty"`

	// ValidBefore The time before which the certificate is valid.
	ValidBefore time.Time `json:"valid_before,omitempty"`
}

// SshCertificateStorage The storage configuration of a managed SSH certificate
type SshCertificateStorage struct {
	// CertificateFile The file that the certificate will be written to
	CertificateFile string `json:"certificate_file,omitempty"`

	// PublicKeyFile The file that contains the public key to be signed
	PublicKeyFile string `json:"public_key_file,omitempty"`
}

// SshManagedCertificate Represents the configuration and storage information of a managed SSH certificate
type SshManagedCertificate struct {
	// Certificate The actual data of a SSH certificate
	Certificate *SshCertificateData `json:"certificate,omitempty"`

	// CertificateConfig Represents the configuration of a managed SSH certificate
	CertificateConfig *SshCertificateConfig `json:"certificate_config,omitempty"`

	// StorageConfig The storage configuration of a managed SSH certificate
	StorageConfig *SshCertificateStorage `json:"storage_config,omitempty"`
}

// SshManagedCertificatesList Returns a list of all the configured managed SSH certificate
type SshManagedCertificatesList struct {
	Data []SshManagedCertificate `json:"data,omitempty"`
}

// X509CertificateConfig Returns the configuration of a managed x509 certificate
type X509CertificateConfig struct {
	// AltNames A list of alternative names (SANs) for the certificate
	AltNames []string `json:"alt_names,omitempty"`

	// CommonName The common name (CN) for the certificate
	CommonName string `json:"common_name,omitempty"`

	// Id Unique identifier for the certificate configuration
	Id string `json:"id,omitempty"`

	// IpSans A list of IP SANs for the certificate
	IpSans []string `json:"ip_sans,omitempty"`

	// Role The role associated with the certificate
	Role string `json:"role,omitempty"`

	// Ttl The time-to-live (TTL) duration for the certificate
	Ttl string `json:"ttl,omitempty"`
}

// X509CertificateData Returns the x509 certificate data
type X509CertificateData struct {
	// EmailAddresses A list of email addresses associated with the certificate.
	EmailAddresses []string `json:"email_addresses,omitempty"`

	// Issuer Information about the certificate's issuer.
	Issuer PkiIssuer `json:"issuer"`

	// NotAfter The end date of the certificate's validity period.
	NotAfter time.Time `json:"not_after"`

	// NotBefore The start date of the certificate's validity period.
	NotBefore time.Time `json:"not_before"`

	// Percentage Lifetime of the certificate.
	Percentage float32 `json:"percentage,omitempty"`

	// Serial The serial number of the x509 certificate.
	Serial string `json:"serial"`

	// Subject The subject of the certificate.
	Subject string `json:"subject"`
}

// X509CertificateStorage The storage configuration of a managed x509 certificate
type X509CertificateStorage struct {
	// CaChainFile The file that the full ca-chain will be written to
	CaChainFile string `json:"ca_chain_file,omitempty"`

	// CaFile The file that the ca will be written to
	CaFile string `json:"ca_file,omitempty"`

	// CertFile The file that the cert will be written to
	CertFile string `json:"cert_file,omitempty"`

	// KeyFile The file that the key will be written to
	KeyFile string `json:"key_file,omitempty"`
}

// X509ManagedCertificate Represents the configuration of a managed x509 certificate
type X509ManagedCertificate struct {
	// CertificateConfig Returns the configuration of a managed x509 certificate
	CertificateConfig *X509CertificateConfig `json:"certificate_config,omitempty"`

	// CertificateData Returns the x509 certificate data
	CertificateData *X509CertificateData     `json:"certificate_data,omitempty"`
	PostHooks       []PostHooks              `json:"post_hooks,omitempty"`
	StorageConfig   []X509CertificateStorage `json:"storage_config,omitempty"`
}

// X509ManagedCertificateList Returns a list of all the configured managed PKI certificate
type X509ManagedCertificateList struct {
	Data []X509ManagedCertificate `json:"data,omitempty"`
}

// BadRequest A generic HTTP problem
type BadRequest = Problem

// Forbidden A generic HTTP problem
type Forbidden = Problem

// InternalServerError A generic HTTP problem
type InternalServerError = Problem

// NotFound A generic HTTP problem
type NotFound = Problem

// NotImplemented A generic HTTP problem
type NotImplemented = Problem

// Unauthorized A generic HTTP problem
type Unauthorized = Problem

// CertsSshGetCertificatesParams defines parameters for CertsSshGetCertificates.
type CertsSshGetCertificatesParams struct {
	// Type Specifies whether to return cert of type user or host. See Vault documentation.
	Type *CertsSshGetCertificatesParamsType `form:"type,omitempty" json:"type,omitempty"`
}

// CertsSshGetCertificatesParamsType defines parameters for CertsSshGetCertificates.
type CertsSshGetCertificatesParamsType string

// CertsSshPostIssueRequestsParams defines parameters for CertsSshPostIssueRequests.
type CertsSshPostIssueRequestsParams struct {
	// Id The id of the SSH host certificate you want to sign
	Id string `form:"id" json:"id"`

	// ForceRenewal Do not check the lifetime of the existing certificate against the threshold and force a new signature of the host key
	ForceRenewal *bool `form:"force-renewal,omitempty" json:"force-renewal,omitempty"`
}

// CertsX509PostIssueRequestsParams defines parameters for CertsX509PostIssueRequests.
type CertsX509PostIssueRequestsParams struct {
	// Id The id of the SSH host certificate you want to sign
	Id string `form:"id" json:"id"`

	// ForceRenewal Do not check the lifetime of the existing certificate against the threshold and force a new signature of the host key
	ForceRenewal *bool `form:"force-renewal,omitempty" json:"force-renewal,omitempty"`
}

// K0sPostActionParams defines parameters for K0sPostAction.
type K0sPostActionParams struct {
	// Action Action to perform for the k0s service
	Action K0sPostActionParamsAction `form:"action" json:"action"`
}

// K0sPostActionParamsAction defines parameters for K0sPostAction.
type K0sPostActionParamsAction string

// LibvirtPostDomainActionParams defines parameters for LibvirtPostDomainAction.
type LibvirtPostDomainActionParams struct {
	// Action Action to perform for the libvirt domain
	Action LibvirtPostDomainActionParamsAction `form:"action" json:"action"`
}

// LibvirtPostDomainActionParamsAction defines parameters for LibvirtPostDomainAction.
type LibvirtPostDomainActionParamsAction string

// PowerPostActionParams defines parameters for PowerPostAction.
type PowerPostActionParams struct {
	// Action Action to perform for the machine
	Action PowerPostActionParamsAction `form:"action" json:"action"`
}

// PowerPostActionParamsAction defines parameters for PowerPostAction.
type PowerPostActionParamsAction string

// PowerRebootManagerPostStatusParams defines parameters for PowerRebootManagerPostStatus.
type PowerRebootManagerPostStatusParams struct {
	// Action Action to perform for the reboot-manager service
	Action PowerRebootManagerPostStatusParamsAction `form:"action" json:"action"`
}

// PowerRebootManagerPostStatusParamsAction defines parameters for PowerRebootManagerPostStatus.
type PowerRebootManagerPostStatusParamsAction string

// ReplicationPostSecretsRequestsParams defines parameters for ReplicationPostSecretsRequests.
type ReplicationPostSecretsRequestsParams struct {
	// SecretPath The KV2 path of the secret that you want to trigger the sync for
	SecretPath string `form:"secret-path" json:"secret-path"`
}

// ServicesUnitStatusPutParams defines parameters for ServicesUnitStatusPut.
type ServicesUnitStatusPutParams struct {
	// Action Action to perform for the system service unit
	Action ServicesUnitStatusPutParamsAction `form:"action" json:"action"`
}

// ServicesUnitStatusPutParamsAction defines parameters for ServicesUnitStatusPut.
type ServicesUnitStatusPutParamsAction string

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CertsAcmeGetCertificates request
	CertsAcmeGetCertificates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CertsAcmeGetCertificate request
	CertsAcmeGetCertificate(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CertsSshGetCertificates request
	CertsSshGetCertificates(ctx context.Context, params *CertsSshGetCertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CertsSshPostIssueRequests request
	CertsSshPostIssueRequests(ctx context.Context, params *CertsSshPostIssueRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CertsSshGetCertificate request
	CertsSshGetCertificate(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CertsX509GetCertificatesList request
	CertsX509GetCertificatesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CertsX509PostIssueRequests request
	CertsX509PostIssueRequests(ctx context.Context, params *CertsX509PostIssueRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CertsX509GetCertificate request
	CertsX509GetCertificate(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InfoGetComponents request
	InfoGetComponents(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// K0sPostAction request
	K0sPostAction(ctx context.Context, params *K0sPostActionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LibvirtPostDomainAction request
	LibvirtPostDomainAction(ctx context.Context, domain string, params *LibvirtPostDomainActionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesInstalledGet request
	PackagesInstalledGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesUpdatesGet request
	PackagesUpdatesGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesUpgradeRequestsPost request
	PackagesUpgradeRequestsPost(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PowerPostAction request
	PowerPostAction(ctx context.Context, params *PowerPostActionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PowerRebootManagerPostStatus request
	PowerRebootManagerPostStatus(ctx context.Context, params *PowerRebootManagerPostStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PowerRebootManagerGetStatus request
	PowerRebootManagerGetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplicationGetHttpItemsList request
	ReplicationGetHttpItemsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplicationGetHttpItem request
	ReplicationGetHttpItem(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplicationGetSecretsItemsList request
	ReplicationGetSecretsItemsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplicationGetSecretsItem request
	ReplicationGetSecretsItem(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplicationPostSecretsRequests request
	ReplicationPostSecretsRequests(ctx context.Context, params *ReplicationPostSecretsRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ServicesUnitLogsGet request
	ServicesUnitLogsGet(ctx context.Context, unit string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ServicesUnitStatusPut request
	ServicesUnitStatusPut(ctx context.Context, unit string, params *ServicesUnitStatusPutParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WolPostMessage request
	WolPostMessage(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CertsAcmeGetCertificates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCertsAcmeGetCertificatesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CertsAcmeGetCertificate(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCertsAcmeGetCertificateRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CertsSshGetCertificates(ctx context.Context, params *CertsSshGetCertificatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCertsSshGetCertificatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CertsSshPostIssueRequests(ctx context.Context, params *CertsSshPostIssueRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCertsSshPostIssueRequestsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CertsSshGetCertificate(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCertsSshGetCertificateRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CertsX509GetCertificatesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCertsX509GetCertificatesListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CertsX509PostIssueRequests(ctx context.Context, params *CertsX509PostIssueRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCertsX509PostIssueRequestsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CertsX509GetCertificate(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCertsX509GetCertificateRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InfoGetComponents(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInfoGetComponentsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) K0sPostAction(ctx context.Context, params *K0sPostActionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewK0sPostActionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LibvirtPostDomainAction(ctx context.Context, domain string, params *LibvirtPostDomainActionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLibvirtPostDomainActionRequest(c.Server, domain, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesInstalledGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesInstalledGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesUpdatesGet(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesUpdatesGetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesUpgradeRequestsPost(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesUpgradeRequestsPostRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PowerPostAction(ctx context.Context, params *PowerPostActionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPowerPostActionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PowerRebootManagerPostStatus(ctx context.Context, params *PowerRebootManagerPostStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPowerRebootManagerPostStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PowerRebootManagerGetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPowerRebootManagerGetStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplicationGetHttpItemsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplicationGetHttpItemsListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplicationGetHttpItem(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplicationGetHttpItemRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplicationGetSecretsItemsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplicationGetSecretsItemsListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplicationGetSecretsItem(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplicationGetSecretsItemRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplicationPostSecretsRequests(ctx context.Context, params *ReplicationPostSecretsRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplicationPostSecretsRequestsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ServicesUnitLogsGet(ctx context.Context, unit string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewServicesUnitLogsGetRequest(c.Server, unit)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ServicesUnitStatusPut(ctx context.Context, unit string, params *ServicesUnitStatusPutParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewServicesUnitStatusPutRequest(c.Server, unit, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WolPostMessage(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWolPostMessageRequest(c.Server, alias)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCertsAcmeGetCertificatesRequest generates requests for CertsAcmeGetCertificates
func NewCertsAcmeGetCertificatesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/certs/acme")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCertsAcmeGetCertificateRequest generates requests for CertsAcmeGetCertificate
func NewCertsAcmeGetCertificateRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/certs/acme/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCertsSshGetCertificatesRequest generates requests for CertsSshGetCertificates
func NewCertsSshGetCertificatesRequest(server string, params *CertsSshGetCertificatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/certs/ssh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCertsSshPostIssueRequestsRequest generates requests for CertsSshPostIssueRequests
func NewCertsSshPostIssueRequestsRequest(server string, params *CertsSshPostIssueRequestsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/certs/ssh/issue-requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ForceRenewal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force-renewal", runtime.ParamLocationQuery, *params.ForceRenewal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCertsSshGetCertificateRequest generates requests for CertsSshGetCertificate
func NewCertsSshGetCertificateRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/certs/ssh/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCertsX509GetCertificatesListRequest generates requests for CertsX509GetCertificatesList
func NewCertsX509GetCertificatesListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/certs/x509")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCertsX509PostIssueRequestsRequest generates requests for CertsX509PostIssueRequests
func NewCertsX509PostIssueRequestsRequest(server string, params *CertsX509PostIssueRequestsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/certs/x509/issue-requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ForceRenewal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force-renewal", runtime.ParamLocationQuery, *params.ForceRenewal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCertsX509GetCertificateRequest generates requests for CertsX509GetCertificate
func NewCertsX509GetCertificateRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/certs/x509/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInfoGetComponentsRequest generates requests for InfoGetComponents
func NewInfoGetComponentsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/info/components")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewK0sPostActionRequest generates requests for K0sPostAction
func NewK0sPostActionRequest(server string, params *K0sPostActionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/k0s/actions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, params.Action); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLibvirtPostDomainActionRequest generates requests for LibvirtPostDomainAction
func NewLibvirtPostDomainActionRequest(server string, domain string, params *LibvirtPostDomainActionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain", runtime.ParamLocationPath, domain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/libvirt/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, params.Action); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesInstalledGetRequest generates requests for PackagesInstalledGet
func NewPackagesInstalledGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/packages/installed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesUpdatesGetRequest generates requests for PackagesUpdatesGet
func NewPackagesUpdatesGetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/packages/updates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesUpgradeRequestsPostRequest generates requests for PackagesUpgradeRequestsPost
func NewPackagesUpgradeRequestsPostRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/packages/upgrade-requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPowerPostActionRequest generates requests for PowerPostAction
func NewPowerPostActionRequest(server string, params *PowerPostActionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/power-state")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, params.Action); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPowerRebootManagerPostStatusRequest generates requests for PowerRebootManagerPostStatus
func NewPowerRebootManagerPostStatusRequest(server string, params *PowerRebootManagerPostStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/power-state/reboot-manager")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, params.Action); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPowerRebootManagerGetStatusRequest generates requests for PowerRebootManagerGetStatus
func NewPowerRebootManagerGetStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/power-state/reboot-manager/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplicationGetHttpItemsListRequest generates requests for ReplicationGetHttpItemsList
func NewReplicationGetHttpItemsListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/replication/http/items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplicationGetHttpItemRequest generates requests for ReplicationGetHttpItem
func NewReplicationGetHttpItemRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/replication/http/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplicationGetSecretsItemsListRequest generates requests for ReplicationGetSecretsItemsList
func NewReplicationGetSecretsItemsListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/replication/secrets/items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplicationGetSecretsItemRequest generates requests for ReplicationGetSecretsItem
func NewReplicationGetSecretsItemRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/replication/secrets/items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplicationPostSecretsRequestsRequest generates requests for ReplicationPostSecretsRequests
func NewReplicationPostSecretsRequestsRequest(server string, params *ReplicationPostSecretsRequestsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/replication/secrets/sync-requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secret-path", runtime.ParamLocationQuery, params.SecretPath); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewServicesUnitLogsGetRequest generates requests for ServicesUnitLogsGet
func NewServicesUnitLogsGetRequest(server string, unit string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "unit", runtime.ParamLocationPath, unit)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/services/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewServicesUnitStatusPutRequest generates requests for ServicesUnitStatusPut
func NewServicesUnitStatusPutRequest(server string, unit string, params *ServicesUnitStatusPutParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "unit", runtime.ParamLocationPath, unit)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/services/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, params.Action); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWolPostMessageRequest generates requests for WolPostMessage
func NewWolPostMessageRequest(server string, alias string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alias", runtime.ParamLocationPath, alias)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/wol-message/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CertsAcmeGetCertificatesWithResponse request
	CertsAcmeGetCertificatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CertsAcmeGetCertificatesResponse, error)

	// CertsAcmeGetCertificateWithResponse request
	CertsAcmeGetCertificateWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CertsAcmeGetCertificateResponse, error)

	// CertsSshGetCertificatesWithResponse request
	CertsSshGetCertificatesWithResponse(ctx context.Context, params *CertsSshGetCertificatesParams, reqEditors ...RequestEditorFn) (*CertsSshGetCertificatesResponse, error)

	// CertsSshPostIssueRequestsWithResponse request
	CertsSshPostIssueRequestsWithResponse(ctx context.Context, params *CertsSshPostIssueRequestsParams, reqEditors ...RequestEditorFn) (*CertsSshPostIssueRequestsResponse, error)

	// CertsSshGetCertificateWithResponse request
	CertsSshGetCertificateWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CertsSshGetCertificateResponse, error)

	// CertsX509GetCertificatesListWithResponse request
	CertsX509GetCertificatesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CertsX509GetCertificatesListResponse, error)

	// CertsX509PostIssueRequestsWithResponse request
	CertsX509PostIssueRequestsWithResponse(ctx context.Context, params *CertsX509PostIssueRequestsParams, reqEditors ...RequestEditorFn) (*CertsX509PostIssueRequestsResponse, error)

	// CertsX509GetCertificateWithResponse request
	CertsX509GetCertificateWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CertsX509GetCertificateResponse, error)

	// InfoGetComponentsWithResponse request
	InfoGetComponentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InfoGetComponentsResponse, error)

	// K0sPostActionWithResponse request
	K0sPostActionWithResponse(ctx context.Context, params *K0sPostActionParams, reqEditors ...RequestEditorFn) (*K0sPostActionResponse, error)

	// LibvirtPostDomainActionWithResponse request
	LibvirtPostDomainActionWithResponse(ctx context.Context, domain string, params *LibvirtPostDomainActionParams, reqEditors ...RequestEditorFn) (*LibvirtPostDomainActionResponse, error)

	// PackagesInstalledGetWithResponse request
	PackagesInstalledGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PackagesInstalledGetResponse, error)

	// PackagesUpdatesGetWithResponse request
	PackagesUpdatesGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PackagesUpdatesGetResponse, error)

	// PackagesUpgradeRequestsPostWithResponse request
	PackagesUpgradeRequestsPostWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PackagesUpgradeRequestsPostResponse, error)

	// PowerPostActionWithResponse request
	PowerPostActionWithResponse(ctx context.Context, params *PowerPostActionParams, reqEditors ...RequestEditorFn) (*PowerPostActionResponse, error)

	// PowerRebootManagerPostStatusWithResponse request
	PowerRebootManagerPostStatusWithResponse(ctx context.Context, params *PowerRebootManagerPostStatusParams, reqEditors ...RequestEditorFn) (*PowerRebootManagerPostStatusResponse, error)

	// PowerRebootManagerGetStatusWithResponse request
	PowerRebootManagerGetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PowerRebootManagerGetStatusResponse, error)

	// ReplicationGetHttpItemsListWithResponse request
	ReplicationGetHttpItemsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReplicationGetHttpItemsListResponse, error)

	// ReplicationGetHttpItemWithResponse request
	ReplicationGetHttpItemWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReplicationGetHttpItemResponse, error)

	// ReplicationGetSecretsItemsListWithResponse request
	ReplicationGetSecretsItemsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReplicationGetSecretsItemsListResponse, error)

	// ReplicationGetSecretsItemWithResponse request
	ReplicationGetSecretsItemWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReplicationGetSecretsItemResponse, error)

	// ReplicationPostSecretsRequestsWithResponse request
	ReplicationPostSecretsRequestsWithResponse(ctx context.Context, params *ReplicationPostSecretsRequestsParams, reqEditors ...RequestEditorFn) (*ReplicationPostSecretsRequestsResponse, error)

	// ServicesUnitLogsGetWithResponse request
	ServicesUnitLogsGetWithResponse(ctx context.Context, unit string, reqEditors ...RequestEditorFn) (*ServicesUnitLogsGetResponse, error)

	// ServicesUnitStatusPutWithResponse request
	ServicesUnitStatusPutWithResponse(ctx context.Context, unit string, params *ServicesUnitStatusPutParams, reqEditors ...RequestEditorFn) (*ServicesUnitStatusPutResponse, error)

	// WolPostMessageWithResponse request
	WolPostMessageWithResponse(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*WolPostMessageResponse, error)
}

type CertsAcmeGetCertificatesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *AcmeManagedCertificateList
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r CertsAcmeGetCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CertsAcmeGetCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CertsAcmeGetCertificateResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *AcmeManagedCertificate
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r CertsAcmeGetCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CertsAcmeGetCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CertsSshGetCertificatesResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]SshManagedCertificatesList
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r CertsSshGetCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CertsSshGetCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CertsSshPostIssueRequestsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r CertsSshPostIssueRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CertsSshPostIssueRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CertsSshGetCertificateResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *SshManagedCertificate
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r CertsSshGetCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CertsSshGetCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CertsX509GetCertificatesListResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *[]X509ManagedCertificateList
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r CertsX509GetCertificatesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CertsX509GetCertificatesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CertsX509PostIssueRequestsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r CertsX509PostIssueRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CertsX509PostIssueRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CertsX509GetCertificateResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *X509ManagedCertificate
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r CertsX509GetCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CertsX509GetCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InfoGetComponentsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *InfoComponents
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r InfoGetComponentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InfoGetComponentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type K0sPostActionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r K0sPostActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r K0sPostActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LibvirtPostDomainActionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r LibvirtPostDomainActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LibvirtPostDomainActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesInstalledGetResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *PackagesInstalled
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r PackagesInstalledGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesInstalledGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesUpdatesGetResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *PackageUpdates
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r PackagesUpdatesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesUpdatesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesUpgradeRequestsPostResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r PackagesUpgradeRequestsPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesUpgradeRequestsPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PowerPostActionResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r PowerPostActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PowerPostActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PowerRebootManagerPostStatusResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r PowerRebootManagerPostStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PowerRebootManagerPostStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PowerRebootManagerGetStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Status *string `json:"status,omitempty"`
	}
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r PowerRebootManagerGetStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PowerRebootManagerGetStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplicationGetHttpItemsListResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReplicationHttpItemsList
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r ReplicationGetHttpItemsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplicationGetHttpItemsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplicationGetHttpItemResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReplicationHttpItem
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r ReplicationGetHttpItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplicationGetHttpItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplicationGetSecretsItemsListResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReplicationSecretsItemsList
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r ReplicationGetSecretsItemsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplicationGetSecretsItemsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplicationGetSecretsItemResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ReplicationSecretsItem
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r ReplicationGetSecretsItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplicationGetSecretsItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplicationPostSecretsRequestsResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r ReplicationPostSecretsRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplicationPostSecretsRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ServicesUnitLogsGetResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	JSON200                   *ServiceLogsData
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON401 *Unauthorized
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r ServicesUnitLogsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ServicesUnitLogsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ServicesUnitStatusPutResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r ServicesUnitStatusPutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ServicesUnitStatusPutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WolPostMessageResponse struct {
	Body                      []byte
	HTTPResponse              *http.Response
	ApplicationproblemJSON400 *BadRequest
	ApplicationproblemJSON403 *Forbidden
	ApplicationproblemJSON404 *NotFound
	ApplicationproblemJSON500 *InternalServerError
	ApplicationproblemJSON501 *NotImplemented
}

// Status returns HTTPResponse.Status
func (r WolPostMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WolPostMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CertsAcmeGetCertificatesWithResponse request returning *CertsAcmeGetCertificatesResponse
func (c *ClientWithResponses) CertsAcmeGetCertificatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CertsAcmeGetCertificatesResponse, error) {
	rsp, err := c.CertsAcmeGetCertificates(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCertsAcmeGetCertificatesResponse(rsp)
}

// CertsAcmeGetCertificateWithResponse request returning *CertsAcmeGetCertificateResponse
func (c *ClientWithResponses) CertsAcmeGetCertificateWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CertsAcmeGetCertificateResponse, error) {
	rsp, err := c.CertsAcmeGetCertificate(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCertsAcmeGetCertificateResponse(rsp)
}

// CertsSshGetCertificatesWithResponse request returning *CertsSshGetCertificatesResponse
func (c *ClientWithResponses) CertsSshGetCertificatesWithResponse(ctx context.Context, params *CertsSshGetCertificatesParams, reqEditors ...RequestEditorFn) (*CertsSshGetCertificatesResponse, error) {
	rsp, err := c.CertsSshGetCertificates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCertsSshGetCertificatesResponse(rsp)
}

// CertsSshPostIssueRequestsWithResponse request returning *CertsSshPostIssueRequestsResponse
func (c *ClientWithResponses) CertsSshPostIssueRequestsWithResponse(ctx context.Context, params *CertsSshPostIssueRequestsParams, reqEditors ...RequestEditorFn) (*CertsSshPostIssueRequestsResponse, error) {
	rsp, err := c.CertsSshPostIssueRequests(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCertsSshPostIssueRequestsResponse(rsp)
}

// CertsSshGetCertificateWithResponse request returning *CertsSshGetCertificateResponse
func (c *ClientWithResponses) CertsSshGetCertificateWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CertsSshGetCertificateResponse, error) {
	rsp, err := c.CertsSshGetCertificate(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCertsSshGetCertificateResponse(rsp)
}

// CertsX509GetCertificatesListWithResponse request returning *CertsX509GetCertificatesListResponse
func (c *ClientWithResponses) CertsX509GetCertificatesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CertsX509GetCertificatesListResponse, error) {
	rsp, err := c.CertsX509GetCertificatesList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCertsX509GetCertificatesListResponse(rsp)
}

// CertsX509PostIssueRequestsWithResponse request returning *CertsX509PostIssueRequestsResponse
func (c *ClientWithResponses) CertsX509PostIssueRequestsWithResponse(ctx context.Context, params *CertsX509PostIssueRequestsParams, reqEditors ...RequestEditorFn) (*CertsX509PostIssueRequestsResponse, error) {
	rsp, err := c.CertsX509PostIssueRequests(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCertsX509PostIssueRequestsResponse(rsp)
}

// CertsX509GetCertificateWithResponse request returning *CertsX509GetCertificateResponse
func (c *ClientWithResponses) CertsX509GetCertificateWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CertsX509GetCertificateResponse, error) {
	rsp, err := c.CertsX509GetCertificate(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCertsX509GetCertificateResponse(rsp)
}

// InfoGetComponentsWithResponse request returning *InfoGetComponentsResponse
func (c *ClientWithResponses) InfoGetComponentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InfoGetComponentsResponse, error) {
	rsp, err := c.InfoGetComponents(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInfoGetComponentsResponse(rsp)
}

// K0sPostActionWithResponse request returning *K0sPostActionResponse
func (c *ClientWithResponses) K0sPostActionWithResponse(ctx context.Context, params *K0sPostActionParams, reqEditors ...RequestEditorFn) (*K0sPostActionResponse, error) {
	rsp, err := c.K0sPostAction(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseK0sPostActionResponse(rsp)
}

// LibvirtPostDomainActionWithResponse request returning *LibvirtPostDomainActionResponse
func (c *ClientWithResponses) LibvirtPostDomainActionWithResponse(ctx context.Context, domain string, params *LibvirtPostDomainActionParams, reqEditors ...RequestEditorFn) (*LibvirtPostDomainActionResponse, error) {
	rsp, err := c.LibvirtPostDomainAction(ctx, domain, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLibvirtPostDomainActionResponse(rsp)
}

// PackagesInstalledGetWithResponse request returning *PackagesInstalledGetResponse
func (c *ClientWithResponses) PackagesInstalledGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PackagesInstalledGetResponse, error) {
	rsp, err := c.PackagesInstalledGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesInstalledGetResponse(rsp)
}

// PackagesUpdatesGetWithResponse request returning *PackagesUpdatesGetResponse
func (c *ClientWithResponses) PackagesUpdatesGetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PackagesUpdatesGetResponse, error) {
	rsp, err := c.PackagesUpdatesGet(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesUpdatesGetResponse(rsp)
}

// PackagesUpgradeRequestsPostWithResponse request returning *PackagesUpgradeRequestsPostResponse
func (c *ClientWithResponses) PackagesUpgradeRequestsPostWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PackagesUpgradeRequestsPostResponse, error) {
	rsp, err := c.PackagesUpgradeRequestsPost(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesUpgradeRequestsPostResponse(rsp)
}

// PowerPostActionWithResponse request returning *PowerPostActionResponse
func (c *ClientWithResponses) PowerPostActionWithResponse(ctx context.Context, params *PowerPostActionParams, reqEditors ...RequestEditorFn) (*PowerPostActionResponse, error) {
	rsp, err := c.PowerPostAction(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePowerPostActionResponse(rsp)
}

// PowerRebootManagerPostStatusWithResponse request returning *PowerRebootManagerPostStatusResponse
func (c *ClientWithResponses) PowerRebootManagerPostStatusWithResponse(ctx context.Context, params *PowerRebootManagerPostStatusParams, reqEditors ...RequestEditorFn) (*PowerRebootManagerPostStatusResponse, error) {
	rsp, err := c.PowerRebootManagerPostStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePowerRebootManagerPostStatusResponse(rsp)
}

// PowerRebootManagerGetStatusWithResponse request returning *PowerRebootManagerGetStatusResponse
func (c *ClientWithResponses) PowerRebootManagerGetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PowerRebootManagerGetStatusResponse, error) {
	rsp, err := c.PowerRebootManagerGetStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePowerRebootManagerGetStatusResponse(rsp)
}

// ReplicationGetHttpItemsListWithResponse request returning *ReplicationGetHttpItemsListResponse
func (c *ClientWithResponses) ReplicationGetHttpItemsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReplicationGetHttpItemsListResponse, error) {
	rsp, err := c.ReplicationGetHttpItemsList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplicationGetHttpItemsListResponse(rsp)
}

// ReplicationGetHttpItemWithResponse request returning *ReplicationGetHttpItemResponse
func (c *ClientWithResponses) ReplicationGetHttpItemWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReplicationGetHttpItemResponse, error) {
	rsp, err := c.ReplicationGetHttpItem(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplicationGetHttpItemResponse(rsp)
}

// ReplicationGetSecretsItemsListWithResponse request returning *ReplicationGetSecretsItemsListResponse
func (c *ClientWithResponses) ReplicationGetSecretsItemsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ReplicationGetSecretsItemsListResponse, error) {
	rsp, err := c.ReplicationGetSecretsItemsList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplicationGetSecretsItemsListResponse(rsp)
}

// ReplicationGetSecretsItemWithResponse request returning *ReplicationGetSecretsItemResponse
func (c *ClientWithResponses) ReplicationGetSecretsItemWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ReplicationGetSecretsItemResponse, error) {
	rsp, err := c.ReplicationGetSecretsItem(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplicationGetSecretsItemResponse(rsp)
}

// ReplicationPostSecretsRequestsWithResponse request returning *ReplicationPostSecretsRequestsResponse
func (c *ClientWithResponses) ReplicationPostSecretsRequestsWithResponse(ctx context.Context, params *ReplicationPostSecretsRequestsParams, reqEditors ...RequestEditorFn) (*ReplicationPostSecretsRequestsResponse, error) {
	rsp, err := c.ReplicationPostSecretsRequests(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplicationPostSecretsRequestsResponse(rsp)
}

// ServicesUnitLogsGetWithResponse request returning *ServicesUnitLogsGetResponse
func (c *ClientWithResponses) ServicesUnitLogsGetWithResponse(ctx context.Context, unit string, reqEditors ...RequestEditorFn) (*ServicesUnitLogsGetResponse, error) {
	rsp, err := c.ServicesUnitLogsGet(ctx, unit, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseServicesUnitLogsGetResponse(rsp)
}

// ServicesUnitStatusPutWithResponse request returning *ServicesUnitStatusPutResponse
func (c *ClientWithResponses) ServicesUnitStatusPutWithResponse(ctx context.Context, unit string, params *ServicesUnitStatusPutParams, reqEditors ...RequestEditorFn) (*ServicesUnitStatusPutResponse, error) {
	rsp, err := c.ServicesUnitStatusPut(ctx, unit, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseServicesUnitStatusPutResponse(rsp)
}

// WolPostMessageWithResponse request returning *WolPostMessageResponse
func (c *ClientWithResponses) WolPostMessageWithResponse(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*WolPostMessageResponse, error) {
	rsp, err := c.WolPostMessage(ctx, alias, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWolPostMessageResponse(rsp)
}

// ParseCertsAcmeGetCertificatesResponse parses an HTTP response from a CertsAcmeGetCertificatesWithResponse call
func ParseCertsAcmeGetCertificatesResponse(rsp *http.Response) (*CertsAcmeGetCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CertsAcmeGetCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AcmeManagedCertificateList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParseCertsAcmeGetCertificateResponse parses an HTTP response from a CertsAcmeGetCertificateWithResponse call
func ParseCertsAcmeGetCertificateResponse(rsp *http.Response) (*CertsAcmeGetCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CertsAcmeGetCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AcmeManagedCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParseCertsSshGetCertificatesResponse parses an HTTP response from a CertsSshGetCertificatesWithResponse call
func ParseCertsSshGetCertificatesResponse(rsp *http.Response) (*CertsSshGetCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CertsSshGetCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SshManagedCertificatesList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParseCertsSshPostIssueRequestsResponse parses an HTTP response from a CertsSshPostIssueRequestsWithResponse call
func ParseCertsSshPostIssueRequestsResponse(rsp *http.Response) (*CertsSshPostIssueRequestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CertsSshPostIssueRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParseCertsSshGetCertificateResponse parses an HTTP response from a CertsSshGetCertificateWithResponse call
func ParseCertsSshGetCertificateResponse(rsp *http.Response) (*CertsSshGetCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CertsSshGetCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SshManagedCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParseCertsX509GetCertificatesListResponse parses an HTTP response from a CertsX509GetCertificatesListWithResponse call
func ParseCertsX509GetCertificatesListResponse(rsp *http.Response) (*CertsX509GetCertificatesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CertsX509GetCertificatesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []X509ManagedCertificateList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParseCertsX509PostIssueRequestsResponse parses an HTTP response from a CertsX509PostIssueRequestsWithResponse call
func ParseCertsX509PostIssueRequestsResponse(rsp *http.Response) (*CertsX509PostIssueRequestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CertsX509PostIssueRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParseCertsX509GetCertificateResponse parses an HTTP response from a CertsX509GetCertificateWithResponse call
func ParseCertsX509GetCertificateResponse(rsp *http.Response) (*CertsX509GetCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CertsX509GetCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest X509ManagedCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParseInfoGetComponentsResponse parses an HTTP response from a InfoGetComponentsWithResponse call
func ParseInfoGetComponentsResponse(rsp *http.Response) (*InfoGetComponentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InfoGetComponentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InfoComponents
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParseK0sPostActionResponse parses an HTTP response from a K0sPostActionWithResponse call
func ParseK0sPostActionResponse(rsp *http.Response) (*K0sPostActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &K0sPostActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParseLibvirtPostDomainActionResponse parses an HTTP response from a LibvirtPostDomainActionWithResponse call
func ParseLibvirtPostDomainActionResponse(rsp *http.Response) (*LibvirtPostDomainActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LibvirtPostDomainActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParsePackagesInstalledGetResponse parses an HTTP response from a PackagesInstalledGetWithResponse call
func ParsePackagesInstalledGetResponse(rsp *http.Response) (*PackagesInstalledGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesInstalledGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackagesInstalled
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParsePackagesUpdatesGetResponse parses an HTTP response from a PackagesUpdatesGetWithResponse call
func ParsePackagesUpdatesGetResponse(rsp *http.Response) (*PackagesUpdatesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesUpdatesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackageUpdates
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParsePackagesUpgradeRequestsPostResponse parses an HTTP response from a PackagesUpgradeRequestsPostWithResponse call
func ParsePackagesUpgradeRequestsPostResponse(rsp *http.Response) (*PackagesUpgradeRequestsPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesUpgradeRequestsPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParsePowerPostActionResponse parses an HTTP response from a PowerPostActionWithResponse call
func ParsePowerPostActionResponse(rsp *http.Response) (*PowerPostActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PowerPostActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParsePowerRebootManagerPostStatusResponse parses an HTTP response from a PowerRebootManagerPostStatusWithResponse call
func ParsePowerRebootManagerPostStatusResponse(rsp *http.Response) (*PowerRebootManagerPostStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PowerRebootManagerPostStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParsePowerRebootManagerGetStatusResponse parses an HTTP response from a PowerRebootManagerGetStatusWithResponse call
func ParsePowerRebootManagerGetStatusResponse(rsp *http.Response) (*PowerRebootManagerGetStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PowerRebootManagerGetStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParseReplicationGetHttpItemsListResponse parses an HTTP response from a ReplicationGetHttpItemsListWithResponse call
func ParseReplicationGetHttpItemsListResponse(rsp *http.Response) (*ReplicationGetHttpItemsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplicationGetHttpItemsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReplicationHttpItemsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParseReplicationGetHttpItemResponse parses an HTTP response from a ReplicationGetHttpItemWithResponse call
func ParseReplicationGetHttpItemResponse(rsp *http.Response) (*ReplicationGetHttpItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplicationGetHttpItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReplicationHttpItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParseReplicationGetSecretsItemsListResponse parses an HTTP response from a ReplicationGetSecretsItemsListWithResponse call
func ParseReplicationGetSecretsItemsListResponse(rsp *http.Response) (*ReplicationGetSecretsItemsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplicationGetSecretsItemsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReplicationSecretsItemsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParseReplicationGetSecretsItemResponse parses an HTTP response from a ReplicationGetSecretsItemWithResponse call
func ParseReplicationGetSecretsItemResponse(rsp *http.Response) (*ReplicationGetSecretsItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplicationGetSecretsItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReplicationSecretsItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParseReplicationPostSecretsRequestsResponse parses an HTTP response from a ReplicationPostSecretsRequestsWithResponse call
func ParseReplicationPostSecretsRequestsResponse(rsp *http.Response) (*ReplicationPostSecretsRequestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplicationPostSecretsRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParseServicesUnitLogsGetResponse parses an HTTP response from a ServicesUnitLogsGetWithResponse call
func ParseServicesUnitLogsGetResponse(rsp *http.Response) (*ServicesUnitLogsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ServicesUnitLogsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceLogsData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParseServicesUnitStatusPutResponse parses an HTTP response from a ServicesUnitStatusPutWithResponse call
func ParseServicesUnitStatusPutResponse(rsp *http.Response) (*ServicesUnitStatusPutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ServicesUnitStatusPutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// ParseWolPostMessageResponse parses an HTTP response from a WolPostMessageWithResponse call
func ParseWolPostMessageResponse(rsp *http.Response) (*WolPostMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WolPostMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 501:
		var dest NotImplemented
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationproblemJSON501 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAD//5pO88DmmgAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
